import { Injectable, Optional, SkipSelf, Component, ElementRef, Input, KeyValueDiffers, Renderer2, NgModule } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { of, throwError } from 'rxjs';
import { map, tap, catchError, finalize, share } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SvgIconRegistryService {
    /**
     * @param {?} http
     */
    constructor(http) {
        this.http = http;
        this.iconsByUrl = new Map();
        this.iconsLoadingByUrl = new Map();
    }
    /**
     * Add a SVG to the registry by passing a name and the SVG.
     * @param {?} name
     * @param {?} data
     * @return {?}
     */
    addSvg(name, data) {
        if (!this.iconsByUrl.has(name)) {
            const /** @type {?} */ div = document.createElement('DIV');
            div.innerHTML = data;
            const /** @type {?} */ svg = /** @type {?} */ (div.querySelector('svg'));
            this.iconsByUrl.set(name, svg);
        }
    }
    /**
     * Load a SVG to the registry from a URL.
     * @param {?} url
     * @return {?}
     */
    loadSvg(url) {
        if (this.iconsByUrl.has(url)) {
            return of(this.iconsByUrl.get(url));
        }
        else if (this.iconsLoadingByUrl.has(url)) {
            return this.iconsLoadingByUrl.get(url);
        }
        else {
            const /** @type {?} */ o = /** @type {?} */ (this.http.get(url, { responseType: 'text' }).pipe(map(svg => {
                const /** @type {?} */ div = document.createElement('DIV');
                div.innerHTML = svg;
                return /** @type {?} */ (div.querySelector('svg'));
            }), tap(svg => this.iconsByUrl.set(url, svg)), catchError(err => {
                console.error(err);
                return throwError(err);
            }), finalize(() => this.iconsLoadingByUrl.delete(url)), share()));
            this.iconsLoadingByUrl.set(url, o);
            return o;
        }
    }
    /**
     * Remove a SVG from the registry by URL (or name).
     * @param {?} url
     * @return {?}
     */
    unloadSvg(url) {
        if (this.iconsByUrl.has(url)) {
            this.iconsByUrl.delete(url);
        }
    }
}
SvgIconRegistryService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
SvgIconRegistryService.ctorParameters = () => [
    { type: HttpClient, },
];
/**
 * @param {?} parentRegistry
 * @param {?} http
 * @return {?}
 */
function SVG_ICON_REGISTRY_PROVIDER_FACTORY(parentRegistry, http) {
    return parentRegistry || new SvgIconRegistryService(http);
}
const SVG_ICON_REGISTRY_PROVIDER = {
    provide: SvgIconRegistryService,
    deps: [[new Optional(), new SkipSelf(), SvgIconRegistryService], HttpClient],
    useFactory: SVG_ICON_REGISTRY_PROVIDER_FACTORY
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SvgIconComponent {
    /**
     * @param {?} element
     * @param {?} differs
     * @param {?} renderer
     * @param {?} iconReg
     */
    constructor(element, differs, renderer, iconReg) {
        this.element = element;
        this.differs = differs;
        this.renderer = renderer;
        this.iconReg = iconReg;
        this.stretch = false;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set svgStyle(v) {
        this._svgStyle = v;
        if (!this.differ && v) {
            this.differ = this.differs.find(v).create();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.init();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy();
    }
    /**
     * @param {?} changeRecord
     * @return {?}
     */
    ngOnChanges(changeRecord) {
        if (changeRecord['src']) {
            if (this.svg) {
                this.destroy();
            }
            this.init();
        }
        if (changeRecord['stretch']) {
            this.stylize();
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.svg && this.differ) {
            const /** @type {?} */ changes = this.differ.diff(this._svgStyle);
            if (changes) {
                this.applyChanges(changes);
            }
        }
    }
    /**
     * @return {?}
     */
    init() {
        this.icnSub = this.iconReg.loadSvg(this.src).subscribe(svg => {
            this.setSvg(svg);
            this.resetDiffer();
        });
    }
    /**
     * @return {?}
     */
    destroy() {
        this.svg = undefined;
        this.differ = undefined;
        if (this.icnSub) {
            this.icnSub.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    resetDiffer() {
        if (this._svgStyle && !this.differ) {
            this.differ = this.differs.find(this._svgStyle).create();
        }
    }
    /**
     * @param {?} svg
     * @return {?}
     */
    setSvg(svg) {
        if (svg) {
            this.svg = svg;
            const /** @type {?} */ icon = /** @type {?} */ (svg.cloneNode(true));
            const /** @type {?} */ elem = this.element.nativeElement;
            elem.innerHTML = '';
            this.renderer.appendChild(elem, icon);
            this.stylize();
        }
    }
    /**
     * @return {?}
     */
    stylize() {
        if (this.svg) {
            const /** @type {?} */ svg = this.element.nativeElement.firstChild;
            if (this.stretch === true) {
                this.renderer.setAttribute(svg, 'preserveAspectRatio', 'none');
            }
            else if (this.stretch === false) {
                this.renderer.removeAttribute(svg, 'preserveAspectRatio');
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    applyChanges(changes) {
        changes.forEachRemovedItem((record) => this.setStyle(record.key, null));
        changes.forEachAddedItem((record) => this.setStyle(record.key, record.currentValue));
        changes.forEachChangedItem((record) => this.setStyle(record.key, record.currentValue));
    }
    /**
     * @param {?} nameAndUnit
     * @param {?} value
     * @return {?}
     */
    setStyle(nameAndUnit, value) {
        const [name, unit] = nameAndUnit.split('.');
        value = value !== null && unit ? `${value}${unit}` : value;
        const /** @type {?} */ svg = this.element.nativeElement.firstChild;
        if (value !== null) {
            this.renderer.setStyle(svg, name, /** @type {?} */ (value));
        }
        else {
            this.renderer.removeStyle(svg, name);
        }
    }
}
SvgIconComponent.decorators = [
    { type: Component, args: [{
                selector: 'svg-icon',
                styles: [`:host { display: inline-block; }`],
                template: '<ng-content></ng-content>'
            },] },
];
/** @nocollapse */
SvgIconComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: KeyValueDiffers, },
    { type: Renderer2, },
    { type: SvgIconRegistryService, },
];
SvgIconComponent.propDecorators = {
    "src": [{ type: Input },],
    "stretch": [{ type: Input },],
    "svgStyle": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AngularSvgIconModule {
}
AngularSvgIconModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                ],
                declarations: [SvgIconComponent],
                providers: [SVG_ICON_REGISTRY_PROVIDER],
                exports: [SvgIconComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { AngularSvgIconModule, SvgIconRegistryService, SVG_ICON_REGISTRY_PROVIDER_FACTORY, SVG_ICON_REGISTRY_PROVIDER, SvgIconComponent };
//# sourceMappingURL=angular-svg-icon.js.map
