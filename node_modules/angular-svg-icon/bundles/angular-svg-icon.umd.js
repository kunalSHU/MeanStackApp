(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common/http'), require('rxjs'), require('rxjs/operators'), require('@angular/common')) :
	typeof define === 'function' && define.amd ? define('angular-svg-icon', ['exports', '@angular/core', '@angular/common/http', 'rxjs', 'rxjs/operators', '@angular/common'], factory) :
	(factory((global['angular-svg-icon'] = {}),global.ng.core,global.ng.common.http,global.rxjs,global.Rx.Observable.prototype,global.ng.common));
}(this, (function (exports,core,http,rxjs,operators,common) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */










function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

var SvgIconRegistryService = /** @class */ (function () {
    function SvgIconRegistryService(http$$1) {
        this.http = http$$1;
        this.iconsByUrl = new Map();
        this.iconsLoadingByUrl = new Map();
    }
    SvgIconRegistryService.prototype.addSvg = function (name, data) {
        if (!this.iconsByUrl.has(name)) {
            var div = document.createElement('DIV');
            div.innerHTML = data;
            var svg = (div.querySelector('svg'));
            this.iconsByUrl.set(name, svg);
        }
    };
    SvgIconRegistryService.prototype.loadSvg = function (url) {
        var _this = this;
        if (this.iconsByUrl.has(url)) {
            return rxjs.of(this.iconsByUrl.get(url));
        }
        else if (this.iconsLoadingByUrl.has(url)) {
            return this.iconsLoadingByUrl.get(url);
        }
        else {
            var o = (this.http.get(url, { responseType: 'text' }).pipe(operators.map(function (svg) {
                var div = document.createElement('DIV');
                div.innerHTML = svg;
                return (div.querySelector('svg'));
            }), operators.tap(function (svg) { return _this.iconsByUrl.set(url, svg); }), operators.catchError(function (err) {
                console.error(err);
                return rxjs.throwError(err);
            }), operators.finalize(function () { return _this.iconsLoadingByUrl.delete(url); }), operators.share()));
            this.iconsLoadingByUrl.set(url, o);
            return o;
        }
    };
    SvgIconRegistryService.prototype.unloadSvg = function (url) {
        if (this.iconsByUrl.has(url)) {
            this.iconsByUrl.delete(url);
        }
    };
    return SvgIconRegistryService;
}());
SvgIconRegistryService.decorators = [
    { type: core.Injectable },
];
SvgIconRegistryService.ctorParameters = function () { return [
    { type: http.HttpClient, },
]; };
function SVG_ICON_REGISTRY_PROVIDER_FACTORY(parentRegistry, http$$1) {
    return parentRegistry || new SvgIconRegistryService(http$$1);
}
var SVG_ICON_REGISTRY_PROVIDER = {
    provide: SvgIconRegistryService,
    deps: [[new core.Optional(), new core.SkipSelf(), SvgIconRegistryService], http.HttpClient],
    useFactory: SVG_ICON_REGISTRY_PROVIDER_FACTORY
};
var SvgIconComponent = /** @class */ (function () {
    function SvgIconComponent(element, differs, renderer, iconReg) {
        this.element = element;
        this.differs = differs;
        this.renderer = renderer;
        this.iconReg = iconReg;
        this.stretch = false;
    }
    Object.defineProperty(SvgIconComponent.prototype, "svgStyle", {
        set: function (v) {
            this._svgStyle = v;
            if (!this.differ && v) {
                this.differ = this.differs.find(v).create();
            }
        },
        enumerable: true,
        configurable: true
    });
    SvgIconComponent.prototype.ngOnInit = function () {
        this.init();
    };
    SvgIconComponent.prototype.ngOnDestroy = function () {
        this.destroy();
    };
    SvgIconComponent.prototype.ngOnChanges = function (changeRecord) {
        if (changeRecord['src']) {
            if (this.svg) {
                this.destroy();
            }
            this.init();
        }
        if (changeRecord['stretch']) {
            this.stylize();
        }
    };
    SvgIconComponent.prototype.ngDoCheck = function () {
        if (this.svg && this.differ) {
            var changes = this.differ.diff(this._svgStyle);
            if (changes) {
                this.applyChanges(changes);
            }
        }
    };
    SvgIconComponent.prototype.init = function () {
        var _this = this;
        this.icnSub = this.iconReg.loadSvg(this.src).subscribe(function (svg) {
            _this.setSvg(svg);
            _this.resetDiffer();
        });
    };
    SvgIconComponent.prototype.destroy = function () {
        this.svg = undefined;
        this.differ = undefined;
        if (this.icnSub) {
            this.icnSub.unsubscribe();
        }
    };
    SvgIconComponent.prototype.resetDiffer = function () {
        if (this._svgStyle && !this.differ) {
            this.differ = this.differs.find(this._svgStyle).create();
        }
    };
    SvgIconComponent.prototype.setSvg = function (svg) {
        if (svg) {
            this.svg = svg;
            var icon = (svg.cloneNode(true));
            var elem = this.element.nativeElement;
            elem.innerHTML = '';
            this.renderer.appendChild(elem, icon);
            this.stylize();
        }
    };
    SvgIconComponent.prototype.stylize = function () {
        if (this.svg) {
            var svg = this.element.nativeElement.firstChild;
            if (this.stretch === true) {
                this.renderer.setAttribute(svg, 'preserveAspectRatio', 'none');
            }
            else if (this.stretch === false) {
                this.renderer.removeAttribute(svg, 'preserveAspectRatio');
            }
        }
    };
    SvgIconComponent.prototype.applyChanges = function (changes) {
        var _this = this;
        changes.forEachRemovedItem(function (record) { return _this.setStyle(record.key, null); });
        changes.forEachAddedItem(function (record) { return _this.setStyle(record.key, record.currentValue); });
        changes.forEachChangedItem(function (record) { return _this.setStyle(record.key, record.currentValue); });
    };
    SvgIconComponent.prototype.setStyle = function (nameAndUnit, value) {
        var _a = __read(nameAndUnit.split('.'), 2), name = _a[0], unit = _a[1];
        value = value !== null && unit ? "" + value + unit : value;
        var svg = this.element.nativeElement.firstChild;
        if (value !== null) {
            this.renderer.setStyle(svg, name, (value));
        }
        else {
            this.renderer.removeStyle(svg, name);
        }
    };
    return SvgIconComponent;
}());
SvgIconComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'svg-icon',
                styles: [":host { display: inline-block; }"],
                template: '<ng-content></ng-content>'
            },] },
];
SvgIconComponent.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: core.KeyValueDiffers, },
    { type: core.Renderer2, },
    { type: SvgIconRegistryService, },
]; };
SvgIconComponent.propDecorators = {
    "src": [{ type: core.Input },],
    "stretch": [{ type: core.Input },],
    "svgStyle": [{ type: core.Input },],
};
var AngularSvgIconModule = /** @class */ (function () {
    function AngularSvgIconModule() {
    }
    return AngularSvgIconModule;
}());
AngularSvgIconModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    common.CommonModule,
                ],
                declarations: [SvgIconComponent],
                providers: [SVG_ICON_REGISTRY_PROVIDER],
                exports: [SvgIconComponent]
            },] },
];

exports.AngularSvgIconModule = AngularSvgIconModule;
exports.SvgIconRegistryService = SvgIconRegistryService;
exports.SVG_ICON_REGISTRY_PROVIDER_FACTORY = SVG_ICON_REGISTRY_PROVIDER_FACTORY;
exports.SVG_ICON_REGISTRY_PROVIDER = SVG_ICON_REGISTRY_PROVIDER;
exports.SvgIconComponent = SvgIconComponent;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=angular-svg-icon.umd.js.map
